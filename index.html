    <!DOCTYPE html>
    <html lang="en">
    <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Minecraft Server List</title>
    <style>
    :root{
        --bg:#0f1724;
        --card:#0b1220;
        --muted:#94a3b8;
        --accent:#60a5fa;
        --glass:rgba(255,255,255,0.03)
    }
    *{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
    html,body,#app{height:100%;margin:0;background:linear-gradient(180deg,#071024 0%, #081423 60%);color:#e6eef8}
    .container{max-width:1100px;margin:28px auto;padding:18px}
    header{display:flex;gap:16px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    h1{font-size:26px;margin:0}
    .controls{display:flex;gap:10px;align-items:center;margin-top:12px;width:100%;flex-wrap:wrap}
    input[type=text]{flex:1;background:var(--card);border:1px solid rgba(255,255,255,0.03);padding:10px 12px;border-radius:10px;color:inherit;min-width:200px}
    button{background:linear-gradient(180deg,var(--accent),#3b82f6);border:none;padding:10px 16px;border-radius:10px;color:#04243a;font-weight:600;cursor:pointer;transition:0.2s}
    button:hover{opacity:0.85}

    /* main grid: left = server list, right = sidebar */
    .grid{
        display:grid;
        grid-template-columns:1fr 360px;
        gap:18px;
        margin-top:24px;
        align-items:start; /* ensure left and right align at top */
    }

    /* server list now uses an internal responsive grid so cards wrap */
    #serverList{
        display:grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap:18px;
        align-content:start;
        /* allow it to scroll on short viewports so sidebar stays visible */
        max-height: calc(100vh - 200px);
        overflow:auto;
        padding-right:6px; /* prevent content hitting scrollbar */
    }

    /* keep consistent card sizing so layout doesn't jump */
    .server-card{
        display:flex;
        flex-direction:column;
        gap:8px;
        transition:0.2s;
        border:1px solid rgba(255,255,255,0.03);
        padding:14px;
        border-radius:12px;
        background:var(--card);
        min-height:120px; /* keeps card heights consistent */
        justify-content:space-between;
    }
    .server-card:hover{border-color:var(--accent);transform:translateY(-2px)}
    .server-card h2{margin:0;font-size:20px}
    .server-card .players{font-size:14px;color:var(--muted)}
    .server-card .status{font-weight:600;font-size:13px}
    .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:14px;border-radius:12px;border:1px solid rgba(255,255,255,0.03)}
    .stat-list{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px}
    .stat{flex:1;background:var(--glass);padding:10px;border-radius:10px;min-width:120px;text-align:center}
    .muted{color:var(--muted);font-size:13px}
    .history{max-height:260px;overflow:auto;margin-top:10px;border-radius:8px;padding:6px;background:rgba(255,255,255,0.01)}
    .row{display:flex;justify-content:space-between;gap:8px;padding:8px;border-radius:6px}

    /* make sidebar sticky so it doesn't get pushed below long lists */
    .sidebar{
        position:relative;
    }
    .sidebar .card{
        position:sticky;
        top:28px;
    }

    /* small screens: collapse to single column and restore natural flow */
    @media (max-width:920px){
        .grid{grid-template-columns:1fr;}
        .controls{flex-direction:column;align-items:stretch}
        input[type=text]{width:100%}
        #serverList{
            grid-template-columns: 1fr; /* single column on small screens */
            max-height: none;
            overflow:visible;
            padding-right:0;
        }
        .sidebar .card{position:static; top:auto;}
        /* Place the sidebar (stat card) above the server list on small screens */
@media (max-width:920px){
  .grid {
    /* keep single column but switch to flex so ordering works predictably */
    display: flex;
    flex-direction: column;
  }
  .sidebar {
    order: -1; /* moves sidebar to the top */
  }
  /* ensure server list stays after sidebar */
  #serverList {
    order: 0;
  }
}

    }
    </style>
    </head>
    <body>
    <div id="app" class="container">
        <header>
            <h1>Minecraft Server List</h1>
            <div class="controls">
                <input id="serverSearch" type="text" placeholder="Search servers...">
                <button id="searchBtn">Search</button>
                <button id="submit">Submit Server</button>
            </div>
        </header>

        <div class="grid">
            <!-- Server list (left column) -->
            <div id="serverList" aria-live="polite">
                <!-- Example server card(s) — keep or populate dynamically -->
                <div class="server-card" data-addr="play.example.com">
                    <h2>loading</h2>
                    <div class="players">—</div>
                    <div class="status">—</div>
                    <div class="email">—</div>
                </div>

            </div> <!-- ← ADDED: close #serverList so sidebar becomes the right column -->

            <!-- Sidebar -->
            <div class="sidebar">
                <div class="card">
                    <h3>Server Stats</h3>
                    <div class="stat-list">
                        <div class="stat">
                            <div>Total Servers</div>
                            <div id="server">—</div>
                        </div>
                        <div class="stat">
                            <div>Players Online</div>
                            <div id="totalPlayers">—</div>
                        </div>
                        <div class="stat">
                            <div>Top Server</div>
                            <div id="topServer">—</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <footer>
        <div class="container" style="text-align:left; padding:1px; font-size:14px; color:var(--muted);">
            &copy; Craftanalytics 2025. fetched from public servers.
        </div>
    </footer>
    <!-- Include your java.js -->
    <script src="java.js"></script>
    <script>
    // Fetch all server statuses concurrently
    async function updateServerList(){
        const serverCards = Array.from(document.querySelectorAll('.server-card'));
        const promises = serverCards.map(card => {
            const addr = card.dataset.addr;
            return fetchStatus(addr)
                .catch(()=>demoStatus(addr))  // fallback if fetch fails
                .then(status=>{
                    card.querySelector('.players').textContent = `${status.players} / ${status.maxplayers || '?' } players online`;
                    card.querySelector('.status').textContent = status.players > 0 ? 'Online' : 'Offline';
                    card.querySelector('.status').style.color = status.players > 0 ? '#34d399' : '#f87171';
                    return status;
                });
        });

        const results = await Promise.all(promises);

        // Update sidebar stats
        let totalPlayers = 0;
        let topServer = {name:'', players:0};
        results.forEach(status=>{
            totalPlayers += status.players;
            if(status.players > topServer.players) topServer = {name: status.name, players: status.players};
        });

        document.getElementById('totalPlayers').textContent = totalPlayers;
        document.getElementById('topServer').textContent = topServer.name || '—';
        document.getElementById('server').textContent = results.length;
    }

    // Run after DOM is loaded
    document.addEventListener('DOMContentLoaded', updateServerList);
    </script>



    <script>
    // --- Clickable server cards (unchanged, but included for completeness) ----
    function makeServerCardsClickable(){
        const serverCards = document.querySelectorAll('.server-card');
        serverCards.forEach(card=>{
            const addr = card.dataset.addr || card.getAttribute('data-addr') || '';
            card.style.cursor = 'pointer';
            card.addEventListener('click', ()=>{
                // Navigate to analytics.html with query ?server=...
                if (addr) {
                    window.location.href = `analytics.html?${encodeURIComponent(addr)}`;
                }
            });
        });
    }

    document.addEventListener('DOMContentLoaded', makeServerCardsClickable);

    // Submit button behavior
    document.addEventListener('DOMContentLoaded', function(){
        const submitBtn = document.getElementById('submit');
        if (submitBtn) submitBtn.addEventListener('click', ()=> window.location.href = 'submit.html');
    });
    </script>
<script>
/**
 * Client-side: use your Node API instead of external mcsrvstat.us
 *
 * Drop this script in place of the older fetchStatus/update logic.
 * Assumes server cards have a `data-addr` attribute (like your HTML).
 */

// Minimal fallback in case the API fails
function demoStatus(addr){
    return { players: 0, maxplayers: null, name: addr, online: false };
}

// Fetch the status for a single server using your /api/check endpoint
async function fetchStatus(addr){
    if(!addr) return demoStatus(addr);

    try {
        // call your Node endpoint which returns { online: true/false, players: N }
        const resp = await fetch(`/api/check?ip=${encodeURIComponent(addr)}`, { cache: 'no-store' });
        if (!resp.ok) {
            // non-2xx -> treat as offline/fallback
            return demoStatus(addr);
        }
        const data = await resp.json();

        // The node API returns { online: boolean, players: number }
        const players = Number(data.players || 0);
        const name = addr; // you can enhance to fetch server name from servers.json if desired
        return {
            players,
            maxplayers: null,
            name,
            online: Boolean(data.online)
        };
    } catch (err) {
        // network / parsing error -> fallback
        console.error('fetchStatus error for', addr, err);
        return demoStatus(addr);
    }
}

// Update all server cards using your own API
async function updateServerList(){
    const serverCards = Array.from(document.querySelectorAll('.server-card'));

    if (serverCards.length === 0) {
        document.getElementById('server').textContent = '0';
        document.getElementById('totalPlayers').textContent = '0';
        document.getElementById('topServer').textContent = '—';
        return;
    }

    const promises = serverCards.map(card => {
        const addr = card.dataset.addr || card.getAttribute('data-addr') || 'unknown';
        return fetchStatus(addr)
            .catch(()=> demoStatus(addr))
            .then(status => {
                const players = Number(status.players || 0);
                const maxplayers = (status.maxplayers == null) ? '—' : status.maxplayers;
                const name = status.name || addr;

                const playersEl = card.querySelector('.players');
                const statusEl  = card.querySelector('.status');
                const titleEl   = card.querySelector('h2');

                if (playersEl) playersEl.textContent = `${players} / ${maxplayers} players online`;
                if (statusEl) {
                    statusEl.textContent = (status.online && players > 0) ? 'Online' : (status.online ? 'Online' : 'Offline');
                    statusEl.style.color = (status.online && players > 0) ? '#34d399' : '#f87171';
                }
                if (titleEl && (!titleEl.textContent || titleEl.textContent.trim() === '')) {
                    titleEl.textContent = name;
                }

                return { players, name };
            });
    });

    // wait for all statuses
    const results = await Promise.all(promises);

    // aggregate stats
    let totalPlayers = 0;
    let topServer = { name: '—', players: -1 };

    results.forEach(r => {
        totalPlayers += Number(r.players || 0);
        if (Number(r.players || 0) > topServer.players) {
            topServer = { name: r.name || '—', players: Number(r.players || 0) };
        }
    });

    // use the DOM count of server cards for total servers
    const totalServers = serverCards.length;

    document.getElementById('totalPlayers').textContent = String(totalPlayers);
    document.getElementById('topServer').textContent = topServer.name || '—';
    document.getElementById('server').textContent = String(totalServers);
}

// Run after DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    updateServerList();
    // if you want automatic polling, enable below (adjust interval as desired)
    // setInterval(updateServerList, 30_000);
});
</script>

    </body>
    </html>
